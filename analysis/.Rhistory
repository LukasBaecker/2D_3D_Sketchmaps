}
}
ipt_results[index] <- counter #safe results in an vector where the index is the ID of the participant
}
ipt_mean <- mean(ipt_results)
drawings_2d_import <- read.csv(here("data/Analysis_2D.csv"))# import the csv that contains the analysis data for the 2D drawings
drawings_3d_import <- read.csv(here("data/Analysis_3D.csv")) # import the csv that contains the analysis data for the 3D drawings
# transpose the tables using data.table library
drawings_2d <- transpose(drawings_2d_import)
drawings_3d <- transpose(drawings_3d_import)
# and also shift the col and row names for both lists
rownames(drawings_2d) <- colnames(drawings_2d_import)
colnames(drawings_2d) <- rownames(drawings_2d_import)
rownames(drawings_3d) <- colnames(drawings_3d_import)
colnames(drawings_3d) <- rownames(drawings_3d_import)
# after the transpose the correct colnames are in the first row.
# Use the first row as names and delete the row for both lists
names(drawings_2d)<-drawings_2d[1,]
drawings_2d<-drawings_2d[-1,]
names(drawings_3d)<-drawings_3d[1,]
drawings_3d<-drawings_3d[-1,]
#here create vectors for savig the sum values of the analysis with the length of the number of participants
allSum2d <- vector(length=participant_count)
allSum3d <- vector(length=participant_count)
#create more vectors for saving only the visibility sum and the correctness sum
all_Visibility2D <- vector(length=participant_count)
all_Z_Visibility2D <- vector(length=participant_count) #thinking about only analyzing the z visibility
all_Correct2D <- vector(length=participant_count)
all_Visibility3D <- vector(length=participant_count)
all_Z_Visibility3D <- vector(length=participant_count) #thinking about only analyzing the z visibility
all_Correct3D <- vector(length=participant_count)
for(id in 1:participant_count){
sum2d <- 0
sum2Dvisible <- 0
sum2Dcorrect <-0
sum3d <- 0
sum3Dvisible <- 0
sum3Dcorrect <-0
# evaluate the object relations
for(i in 4:129){
# check how many are correct in 2D
sum2d <- sum2d + as.numeric(drawings_2d[id,i])
# check how many are correct in 3D
sum3d <- sum3d + as.numeric(drawings_3d[id,i])
# compare only the visibility
if ( substr(colnames(drawings_2d)[i],1, 1) == "V" ){
sum2Dvisible <- sum2Dvisible + as.numeric(drawings_2d[id,i])
sum3Dvisible <- sum3Dvisible + as.numeric(drawings_3d[id,i])
}
# compare the visibility of z axis
# compare only the correctness
if ( substr(colnames(drawings_2d)[i],1, 1) == "C" ){
sum2Dcorrect <- sum2Dcorrect + as.numeric(drawings_2d[id,i])
sum3Dcorrect <- sum3Dcorrect + as.numeric(drawings_3d[id,i])
}
}
allSum2d[id]<-sum2d
allSum3d[id]<-sum3d
all_Visibility2D[id]<-sum2Dvisible
all_Visibility3D[id]<-sum3Dvisible
all_Correct2D[id]<-sum2Dcorrect
all_Correct3D[id]<-sum3Dcorrect
}
tutorial_data <- read.csv(here("data/tutorial_politeness_data.csv"))
#
#ncol is: ID, IPT, type of drawing, counter
users_data <- matrix(nrow = participant_count*4, ncol = 5, byrow = FALSE)
colnames(users_data) <- c("ID","IPT","DrawingType","category","score")
users_data_frame <- as.data.frame(users_data)
for(id in 1:participant_count){
users_data_frame[id,1] <- id
users_data_frame[id,2] <- ipt_results[id]
users_data_frame[id,3] <- "2D"
users_data_frame[id,4] <- "visibility"
users_data_frame[id,5] <- as.numeric(all_Visibility2D[id])
users_data_frame[(id+participant_count),1] <- id
users_data_frame[(id+participant_count),2] <- ipt_results[id]
users_data_frame[(id+participant_count),3] <- "3D"
users_data_frame[(id+participant_count),4] <- "visibility"
users_data_frame[(id+participant_count),5] <- all_Visibility3D[id]
users_data_frame[(id+participant_count*2),1] <- id
users_data_frame[(id+participant_count*2),2] <- ipt_results[id]
users_data_frame[(id+participant_count*2),3] <- "2D"
users_data_frame[(id+participant_count*2),4] <- "correctness"
users_data_frame[(id+participant_count*2),5] <- all_Correct2D[id]
users_data_frame[(id+participant_count*3),1] <- id
users_data_frame[(id+participant_count*3),2] <- ipt_results[id]
users_data_frame[(id+participant_count*3),3] <- "3D"
users_data_frame[(id+participant_count*3),4] <- "correctness"
users_data_frame[(id+participant_count*3),5] <- all_Correct3D[id]
}
visible_and_correct.model = lmer(score ~ IPT + category +
(1|ID) + (1|DrawingType), data=users_data_frame, REML = FALSE)
visible_and_correct.null = lmer(score ~ IPT + category +
(1|ID), data=users_data_frame, REML = FALSE)
visible_and_correct.IPTnull = lmer(score ~ category +
(1|ID) + (1|DrawingType), data=users_data_frame, REML = FALSE)
visible_and_correct.Categorynull = lmer(score ~ IPT +
(1|ID) + (1|DrawingType), data=users_data_frame, REML = FALSE)
anova(visible_and_correct.null,visible_and_correct.model)
anova(visible_and_correct.IPTnull,visible_and_correct.model)
anova(visible_and_correct.Categorynull,visible_and_correct.model)
#check if the category and the drawing type interact with each other
effecting_Typ_Cat.model = lmer(score ~ IPT + (1|ID)+ category * (1|DrawingType), data=users_data_frame, REML = FALSE)
effecting_Typ_Cat.null = lmer(score ~ IPT + (1|ID)+ category + (1|DrawingType), data=users_data_frame, REML = FALSE)
anova(effecting_Typ_Cat.null,effecting_Typ_Cat.model)
#check if different baselines when looking at visibility and correctness for individuals make a difference
individualBaseline.model = lmer(score ~ IPT + category +
(1+category|ID) + (1+category|DrawingType), data=users_data_frame, REML = FALSE)
individualBaseline.null = lmer(score ~ IPT + category +
(1+category|ID), data=users_data_frame, REML = FALSE)
anova(individualBaseline.null,individualBaseline.model)
#ncol is: ID, IPT, type of drawing, counter
users_data.prep <- matrix(nrow = participant_count*2, ncol = 4, byrow = FALSE)
colnames(users_data.prep) <- c("ID","IPT","DrawingType","score")
users_data_frame.visible <- as.data.frame(users_data.prep)
users_data_frame.correct <- as.data.frame(users_data.prep)
for(id in 1:participant_count){
users_data_frame.visible[id,1] <- id
users_data_frame.visible[id,2] <- ipt_results[id]
users_data_frame.visible[id,3] <- "2D"
users_data_frame.visible[id,4] <- as.numeric(all_Visibility2D[id])
users_data_frame.visible[(id+participant_count),1] <- id
users_data_frame.visible[(id+participant_count),2] <- ipt_results[id]
users_data_frame.visible[(id+participant_count),3] <- "3D"
users_data_frame.visible[(id+participant_count),4] <- all_Visibility3D[id]
users_data_frame.correct[id,1] <- id
users_data_frame.correct[id,2] <- ipt_results[id]
users_data_frame.correct[id,3] <- "2D"
users_data_frame.correct[id,4] <- all_Correct2D[id]
users_data_frame.correct[(id+participant_count),1] <- id
users_data_frame.correct[(id+participant_count),2] <- ipt_results[id]
users_data_frame.correct[(id+participant_count),3] <- "3D"
users_data_frame.correct[(id+participant_count),4] <- all_Correct3D[id]
}
visible.model = lmer(score ~ IPT + (1|ID) + (1|DrawingType), data=users_data_frame.visible, REML = FALSE)
visible.null = lmer(score ~ IPT + (1|ID), data=users_data_frame.visible, REML = FALSE)
anova(visible.null,visible.model)
correct.model = lmer(score ~ IPT + (1|ID) + (1|DrawingType), data=users_data_frame.correct, REML = FALSE)
correct.null = lmer(score ~ IPT + (1|ID) , data=users_data_frame.correct, REML = FALSE)
anova(visible_and_correct.null,visible_and_correct.model)
visible.plottest = lmer(score ~ IPT + (1|ID) + (1|DrawingType), data=users_data_frame.visible)
estimates(visible.plottest)
visualize(visible.plottest, plot="all",formula = NULL)
# load my standard packages
library(tidyverse)
library(lme4)
library(lmerTest)
library(MuMIn)
library(effects)
library(ggplot2)
library(sjPlot)
#installing flexplot from github
devtools::install_github("dustinfife/flexplot")
#installing flexplot from github
devtools::install_github("dustinfife/flexplot")
# Necessary packages for script.
packages = c("tidyverse", "here",
"plotly", "sf", "knitr", "data.table", "lme4", "lmerTest","flexplot", "MuMIn", "effects", "ggplot2","sjPlot")
# Install and then load them.
package.check <- lapply(
packages,
FUN = function(x) {
if (!require(x, character.only = TRUE)) {
install.packages(x, dependencies = TRUE)
library(x, character.only = TRUE)
}
}
)
install()
install.packages()
install.package()
install.packages("lmerTest")
devtools::install_github("runehaubo/lmerTestR")
#installing flexplot from github
devtools::install_github("dustinfife/flexplot")
devtools::install_github("runehaubo/lmerTestR")
install.packages("lmerTest")
install.packages("Rtools")
install.packages("effects")
install.packages("Rtools")
install.packages("effects")
install.packages("MuMIn")
install.packages("ggplot2")
install.packages("sjPlot")
install.packages("lmerTest")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyverse)
library(here)
library(plotly)
library(sf)
library(here)
library(plotly)
library(sf)
library(knitr)
library(knitr)
library(data.table)
library(lme4)
library(tidyverse)
library(here)
library(plotly)
library(sf)
library(knitr)
library(data.table)
library(lme4)
library(lmerTest)
library(flexplot)
library(MuMIn)
library(effects)
library(sf)
library(knitr)
library(data.table)
library(lme4)
library(lmerTest)
library(flexplot)
library(MuMIn)
library(effects)
library(ggplot2)
library(sjPlot)
# Info for the csv:
# ID is the ID of the participant
# Age is the age of the participant
# Gender is a number from 1 to 4 where 1 means male, 2 means femal, 3 means diverse and 4 means undefined
# Q1 to Q10 are the answers for the IPT
# Order defines the order of drawing tasks. 1 means that the person first drew with pen and paper and 2 means that the person first drew in gravity sketch
# PnP_1 to PnP_6 is the NASA-TLX for pen and paper drawing
# VR_1 to VR_6 is the NASA-TLX for drawing with gravity sketch
questionair <- read.csv(here("data/questionair.csv"))
participant_count <- nrow(questionair) # count the number of participants
# age statistics
age_mean <- mean(questionair$Age)
age_min <- min(questionair$Age)
age_max <- max(questionair$Age)
#boxplot(questionair$Age)
# table showing the gender contribution
gender_table <- table(questionair$Gender)
solution <- c(3,1,4,3,4,3,2,2,2,1)
ipt_results <- vector(length=participant_count)
for (index in 1:participant_count) {
counter <- 0 # counting right answers
for(q in 1:10){
if(questionair[index,paste("Q",q, sep = "")]==solution[q]){
counter<- counter+1
}
}
ipt_results[index] <- counter #safe results in an vector where the index is the ID of the participant
}
ipt_mean <- mean(ipt_results)
#boxplot(itp_results)
drawings_2d_import <- read.csv(here("data/Analysis_2D.csv"))# import the csv that contains the analysis data for the 2D drawings
drawings_3d_import <- read.csv(here("data/Analysis_3D.csv")) # import the csv that contains the analysis data for the 3D drawings
# transpose the tables using data.table library
drawings_2d <- transpose(drawings_2d_import)
drawings_3d <- transpose(drawings_3d_import)
# and also shift the col and row names for both lists
rownames(drawings_2d) <- colnames(drawings_2d_import)
colnames(drawings_2d) <- rownames(drawings_2d_import)
rownames(drawings_3d) <- colnames(drawings_3d_import)
colnames(drawings_3d) <- rownames(drawings_3d_import)
# after the transpose the correct colnames are in the first row.
# Use the first row as names and delete the row for both lists
names(drawings_2d)<-drawings_2d[1,]
drawings_2d<-drawings_2d[-1,]
names(drawings_3d)<-drawings_3d[1,]
drawings_3d<-drawings_3d[-1,]
# drawings_2d.dataframe <- as.data.frame(drawings_2d) # converte to dataframe
# drawings_3d.dataframe <- as.data.frame(drawings_3d) # converte to dataframe
#TODO: work with dataframes rather then vectors
#here create vectors for savig the sum values of the analysis with the length of the number of participants
allSum2d <- vector(length=participant_count)
allSum3d <- vector(length=participant_count)
#create more vectors for saving only the visibility sum and the correctness sum
all_Visibility2D <- vector(length=participant_count)
all_Z_Visibility2D <- vector(length=participant_count) #thinking about only analyzing the z visibility
all_Correct2D <- vector(length=participant_count)
all_Visibility3D <- vector(length=participant_count)
all_Z_Visibility3D <- vector(length=participant_count) #thinking about only analyzing the z visibility
all_Correct3D <- vector(length=participant_count)
for(id in 1:participant_count){
sum2d <- 0
sum2Dvisible <- 0
sum2Dcorrect <-0
sum3d <- 0
sum3Dvisible <- 0
sum3Dcorrect <-0
# evaluate the object relations
for(i in 4:129){
# check how many are correct in 2D
sum2d <- sum2d + as.numeric(drawings_2d[id,i])
# check how many are correct in 3D
sum3d <- sum3d + as.numeric(drawings_3d[id,i])
# compare only the visibility
if ( substr(colnames(drawings_2d)[i],1, 1) == "V" ){
sum2Dvisible <- sum2Dvisible + as.numeric(drawings_2d[id,i])
sum3Dvisible <- sum3Dvisible + as.numeric(drawings_3d[id,i])
}
# compare the visibility of z axis
# compare only the correctness
if ( substr(colnames(drawings_2d)[i],1, 1) == "C" ){
sum2Dcorrect <- sum2Dcorrect + as.numeric(drawings_2d[id,i])
sum3Dcorrect <- sum3Dcorrect + as.numeric(drawings_3d[id,i])
}
}
allSum2d[id]<-sum2d
allSum3d[id]<-sum3d
all_Visibility2D[id]<-sum2Dvisible
all_Visibility3D[id]<-sum3Dvisible
all_Correct2D[id]<-sum2Dcorrect
all_Correct3D[id]<-sum3Dcorrect
}
tutorial_data <- read.csv(here("data/tutorial_politeness_data.csv"))
#
#ncol is: ID, IPT, type of drawing, counter
users_data <- matrix(nrow = participant_count*4, ncol = 5, byrow = FALSE)
colnames(users_data) <- c("ID","IPT","DrawingType","category","score")
users_data_frame <- as.data.frame(users_data)
for(id in 1:participant_count){
users_data_frame[id,1] <- id
users_data_frame[id,2] <- ipt_results[id]
users_data_frame[id,3] <- "2D"
users_data_frame[id,4] <- "visibility"
users_data_frame[id,5] <- as.numeric(all_Visibility2D[id])
users_data_frame[(id+participant_count),1] <- id
users_data_frame[(id+participant_count),2] <- ipt_results[id]
users_data_frame[(id+participant_count),3] <- "3D"
users_data_frame[(id+participant_count),4] <- "visibility"
users_data_frame[(id+participant_count),5] <- all_Visibility3D[id]
users_data_frame[(id+participant_count*2),1] <- id
users_data_frame[(id+participant_count*2),2] <- ipt_results[id]
users_data_frame[(id+participant_count*2),3] <- "2D"
users_data_frame[(id+participant_count*2),4] <- "correctness"
users_data_frame[(id+participant_count*2),5] <- all_Correct2D[id]
users_data_frame[(id+participant_count*3),1] <- id
users_data_frame[(id+participant_count*3),2] <- ipt_results[id]
users_data_frame[(id+participant_count*3),3] <- "3D"
users_data_frame[(id+participant_count*3),4] <- "correctness"
users_data_frame[(id+participant_count*3),5] <- all_Correct3D[id]
}
visible_and_correct.model = lmer(score ~ IPT + category +
(1|ID) + (1|DrawingType), data=users_data_frame, REML = FALSE)
visible_and_correct.null = lmer(score ~ IPT + category +
(1|ID), data=users_data_frame, REML = FALSE)
visible_and_correct.IPTnull = lmer(score ~ category +
(1|ID) + (1|DrawingType), data=users_data_frame, REML = FALSE)
visible_and_correct.Categorynull = lmer(score ~ IPT +
(1|ID) + (1|DrawingType), data=users_data_frame, REML = FALSE)
anova(visible_and_correct.null,visible_and_correct.model)
anova(visible_and_correct.IPTnull,visible_and_correct.model)
anova(visible_and_correct.Categorynull,visible_and_correct.model)
#check if the category and the drawing type interact with each other
effecting_Typ_Cat.model = lmer(score ~ IPT + (1|ID)+ category * (1|DrawingType), data=users_data_frame, REML = FALSE)
effecting_Typ_Cat.null = lmer(score ~ IPT + (1|ID)+ category + (1|DrawingType), data=users_data_frame, REML = FALSE)
anova(effecting_Typ_Cat.null,effecting_Typ_Cat.model)
#check if different baselines when looking at visibility and correctness for individuals make a difference
individualBaseline.model = lmer(score ~ IPT + category +
(1+category|ID) + (1+category|DrawingType), data=users_data_frame, REML = FALSE)
individualBaseline.null = lmer(score ~ IPT + category +
(1+category|ID), data=users_data_frame, REML = FALSE)
anova(individualBaseline.null,individualBaseline.model)
#ncol is: ID, IPT, type of drawing, counter
users_data.prep <- matrix(nrow = participant_count*2, ncol = 4, byrow = FALSE)
colnames(users_data.prep) <- c("ID","IPT","DrawingType","score")
users_data_frame.visible <- as.data.frame(users_data.prep)
users_data_frame.correct <- as.data.frame(users_data.prep)
#TODO: add the order of drawing to the analysis
for(id in 1:participant_count){
users_data_frame.visible[id,1] <- id
users_data_frame.visible[id,2] <- ipt_results[id]
users_data_frame.visible[id,3] <- "2D"
users_data_frame.visible[id,4] <- as.numeric(all_Visibility2D[id])
users_data_frame.visible[(id+participant_count),1] <- id
users_data_frame.visible[(id+participant_count),2] <- ipt_results[id]
users_data_frame.visible[(id+participant_count),3] <- "3D"
users_data_frame.visible[(id+participant_count),4] <- all_Visibility3D[id]
users_data_frame.correct[id,1] <- id
users_data_frame.correct[id,2] <- ipt_results[id]
users_data_frame.correct[id,3] <- "2D"
users_data_frame.correct[id,4] <- all_Correct2D[id]
users_data_frame.correct[(id+participant_count),1] <- id
users_data_frame.correct[(id+participant_count),2] <- ipt_results[id]
users_data_frame.correct[(id+participant_count),3] <- "3D"
users_data_frame.correct[(id+participant_count),4] <- all_Correct3D[id]
}
visible.model = lmer(score ~ IPT + (1|ID) + (1|DrawingType), data=users_data_frame.visible, REML = FALSE)
visible.null = lmer(score ~ IPT + (1|ID), data=users_data_frame.visible, REML = FALSE)
anova(visible.null,visible.model)
correct.model = lmer(score ~ IPT + (1|ID) + (1|DrawingType), data=users_data_frame.correct, REML = FALSE)
correct.null = lmer(score ~ IPT + (1|ID) , data=users_data_frame.correct, REML = FALSE)
anova(visible_and_correct.null,visible_and_correct.model)
read_chunk(file.path("options_jk.R"))
read_chunk("options_jk.R")
read_chunk(file.path("options_jk.R"))
source(here("A.R"))
source(here("/A.R"))
source(here("./A.R"))
source(here("/options_jk.R"))
source(here("options_jk.R"))
View(lmcheck)
source(here("options_jk.R"))
source(here("options_jk.R"))
source(here("options_jk.R"))
read_chunk(file.path("options_jk.R"))
normcheck(visible.model)
lmcheck(visible.model)
#normcheck()
lmercheck(visible.model)
lmercheck(correct.model)
influence(visible.model, obs=TRUE)
view_kable(visible.model)
vif.mer(visible.model)
kappa.mer(visible.model)
?kappa
colldiag.mer(visible.model)
maxcorr.mer(visible.model)
kappa.mer(visible.model)
kappa.mer(correct.model)
kappa.mer(visible.model)
?shapiro.test
print(shapiro.test(visible.model))
shapiro.test(visible.model)
visible.model
print(shapiro.test(users_data_frame.visible))
shapiro.test(users_data_frame.visible)
users_data_frame.visible
users_data_frame.visible[,4]
shapiro.test(users_data_frame.visible[,4])
shapiro.test(users_data_frame.visible[,2])
normcheck(users_data_frame.visible[,2])
normcheck(users_data_frame.visible[,4])
normcheck(users_data_frame.visible[,4])
users_data_frame
normcheck(users_data_frame[,5])
normcheck(users_data_frame[,2])
#error in this function
lmercheck(visible.model)
lmercheck(visible.model)
#running without error
lmcheck(visible.model)
barlett.test(visible.model)
bartlett.test(visible.model)
lmcheck(visible.model)
vif.mer(visible.model)
kappa.mer(visible.model)
kappa.mer(correct.model)
#error
colldiag.mer(visible.model)
#error
maxcorr.mer(visible.model)
#error
view_kable(visible.model)
#running without error
lmcheck(visible.model)
normcheck(users_data_frame.visible[,4]) #visibility score
normcheck(users_data_frame.visible[,4]) #visibility score
#running without error
lmcheck(visible.model)
lmcheck(visible.model)
normcheck(users_data_frame.visible[,4]) #visibility score
#error in this function
lmercheck(visible.model)
lmercheck(visible.model)
lmercheck(correct.model)
lmercheck(visible_and_correct.model)
visible.model.test = lmer(score ~ IPT + (1|ID) + DrawingType, data=users_data_frame.visible, REML = FALSE)
lmcheck(visible.model.test)
?allEffects
#load the script created by Jakub Krukar
source(here("options_jk.R"))
lmcheck(visible.model.test)
correct.model.test = lmer(score ~ IPT + (1|ID) + DrawingType, data=users_data_frame.correct, REML = FALSE)
lmcheck(correct.model.test)
visible_and_correct.model.test = lmer(score ~ IPT + category +
(1|ID) + (1|DrawingType), data=users_data_frame, REML = FALSE)
lmcheck(visible_and_correct.model.test)
visible_and_correct.model.test = lmer(score ~ IPT +
(1|ID) + DrawingType, data=users_data_frame, REML = FALSE)
lmcheck(visible_and_correct.model.test)
lmcheck(visible_and_correct.model.test)
plot(effect("DrawingType",visible.model.test))
#load the script created by Jakub Krukar
source(here("options_jk.R"))
plot(effect("DrawingType",visible.model.test))
plot(effect("DrawingType",visible.model.test))
plot(effect("DrawingType",correct.model.test))
plot(effect("DrawingType",visible_and_correct.model.test))
?effect
effect("DrawingType",visible.model.test)
summary(effect("DrawingType",visible.model.test))
plot(effect("DrawingType",visible.model.test))
plot(effect("DrawingType",visible.model.test))
plot(effect("IPT",visible.model.test))
plot(effect("IPT",correct.model.test))
plot(effect("IPT",visible_and_correct.model.test))
plot(effect("IPT",visible_and_correct.model))
#plotting the drawingtype effect on the score
plot(effect("DrawingType",visible.model.test))
plot(effect("DrawingType",visible.model.test))
plot(effect("DrawingType",visible.model))
#error in this function
lmercheck(visible.model)
lmercheck(visible.model)
#running without error
lmcheck(visible.model)
?fitted
lmcheck(visible.model)
model.comparison(visible_and_correct.model, visible_and_correct.model.test)
visible_and_correct.model.test2 = lmer(score ~ IPT + category +
(1|ID) + (category|DrawingType), data=users_data_frame, REML = FALSE)
model.comparison(visible_and_correct.model, visible_and_correct.model.test2)
model.comparison(visible_and_correct.model, visible_and_correct.model.test2, visible_and_correct.model.test)
visualize(visible_and_correct.model,plot="model")
